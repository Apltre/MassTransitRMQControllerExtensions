Система ретраев:

Система ретраев основана на сигнатурах масстранзитных методов библиотеки GreenPipes.RetryConfigurationExtensions:

None() - как метод в MassTransitRMQExtensions не используется

Immediate(int retryLimit)

Intervals(params TimeSpan[] intervals)

Interval(int retryCount, TimeSpan interval)

Exponential(int retryLimit, TimeSpan minInterval, TimeSpan maxInterval, TimeSpan intervalDelta)  intervalDelta - параметр в котором указывается максимальное значение рандомной "погрешности" которая в идеале позволяет не допускать "одновременной" обработки ретраев. В дефолтных(inmemory) ретраях массранзита можно настраивать, для  "RMQ DLX"(поддерживается с версии 8.0.20220622.1)ретраев не настраивается(равен 0).

Incremental(int retryLimit, TimeSpan initialInterval, TimeSpan intervalIncrement)

(Лог изменений носит условную нумерацию.)

До версий 1:

Жестко прописывались ретраи в памяти МТ как для джобов так и для консьюмеров по схеме Exponential(21, TimeSpan.FromMinutes(2), TimeSpan.FromMinutes(20), TimeSpan.FromMinutes(1)) это ~6 часов ретраев в среднем каждые 20 минут.

С версий 2:

Для джобов жестко зашито расписание в режиме ретраев МТ в памяти  Exponential(21, TimeSpan.FromMinutes(2), TimeSpan.FromMinutes(15), TimeSpan.FromMinutes(1)).

Для консьюмеров "из коробки" используются "RMQ DLX" ретраи Interval(72, TimeSpan.FromMinutes(5))

МТ ретраи в памяти поддерживают все стандартные функции ретраев.

МТ ретраи "RMQ DLX" пока поддерживают только механизм Interval(int retryCount, TimeSpan interval)

Глобальная конфигурация "RMQ DLX" ретраев осуществляется посредством метода ConfigureMassTransitControllers на уровне  конфигурации DI. За это отвечает необязательный параметр globalRetryPolicy(интерфейс IMTRMQERetryPolicy).

Локальная конфигурация ретраев консьюмера осуществляется посредством строкового шаблона в атрибуте SubscribeOn(параметр retryPolicy). Конфигурация ретрая атрибута имеет больший приоритет чем глобальная.

В качестве конфигураторов ретраев выступают типы обертки:

RetryPolicyNone()

       RetryPolicyIntervals(RetryPolicyType retryPolicyType, IEnumerable<TimeSpan> intervals)

       RetryPolicyInterval(RetryPolicyType retryPolicyType, int retryLimit, TimeSpan interval)

       RetryPolicyIncremental(RetryPolicyType retryPolicyType, int retryLimit, TimeSpan initialInterval, TimeSpan intervalIncrement)

       RetryPolicyImmediate(RetryPolicyType retryPolicyType, int retryLimit)

       RetryPolicyExponential(RetryPolicyType retryPolicyType, int retryLimit, TimeSpan minInterval, TimeSpan maxInterval, TimeSpan? intervalDelta = null)

     Параметр RetryPolicyType имеет 3 значения:

None - без ретраев

RabbitMq - кастомная модель ретраев через DLX

Masstransit - cоответствеут модели ретраев в памяти MT

       В рамках МТ ретраев в памяти, эти обертки  участвуют в вызове вышеперечисленных расширений GreenPipes.RetryConfigurationExtensions. В рамках "RMQ DLX" ретраев реализуется кастомная обработка ретраев с применением DLX очередей. На текущий момент реализован только RetryPolicyInterval.

 

С версии 3:

Исправлена возможная проблема с логированием эвента. Раньше эвент было возможно мутировать в контроллере, из за чего в логи могли бы быть неверные данные.

Добавлен атрибут SubscribeEndpoint. Он служит для генерации топологии консьюмера без подписки на какой-либо эксчейндж.

Исправлено построение топологии джобов. Раньше происходило визуальное "зацикливание"(видно в rmq management) топологии эксчейнджа джоба.

У атрибутов подписчиков добавлена перегрузка типа object поля exchange. Это позволяет использовать enum'ы в качестве имени эксчейнджа на который происходит подписка.

Введен явный запрет на использование более одного PublishMessage атрибута на классе.

Делегат-фильтр имени контроллеров в методе ConfigureMassTransitControllers больше не требует обязательного суффикса Controller у класса с методами консьюмерами.

В логах IsSuccessful теперь с 1 L. Граммарнацы рады.

В инфре выполнения метода консьюмера теперь логируется падение резолва зависимостей DI

В методе ConfigureMassTransitControllers  теперь есть параметр eventLoggingEnabled, которые позволяет не логировать приходящий в консьюмер эвент.

В методе ConfigureMassTransitControllers теперь есть делегат consumerExchangeNamingChanger для глобального изменения именований эксчейнджей на которые подписываются консьюмеры(например в случае с какой-то версионностью)

Версия MT поднята до 8.0.3

Текущая версия либы использует Microsoft.Extensions.DependencyInjection.Abstractions версии 6.0.0. Вроде конфликтов с более старыми версиями кора(3.1) не замечено, но надо учитывать.

С версии 4:

Сделана поддержка экспоненциальных ретраев для RMQ ретраера через DLX. Для каждого времени ретрая создается своя DLX очередь именуемая как *имя базовой очереди*_*время до ретрая*_DLX. Так как такой ретраер генерирует много DLX очередей, рекомендуется использовать его только по необходимости. Последний параметр конфигуратора RetryPolicyExponential IntervalDelta не используется из-за принципров работы DLX.

Добавлено GUID поле Id в эвенте джобов, для явного определения дублей и других аномалий в логах.

С версии 5:

Добавлена поддержка dynamic типа в консьюмерах.

С версии 6:

Добавлена поддержка кириллицы в логах.

C версии 7:

Косметический рефакторинг кода

Улучшена проверка регистрации публикуемых сообщений. Раньше если библиотека с типом сообщения не была инициализирована перед инициализацией МТ, то при публикации сообщения не возникало исключение, в результате чего сообщение просто пропадало.

C версии 8:

Рефакторинг по советам VS

Улучшена валидация дублей атрибутов консьюмера(фикс)

Поддержка контекста сообщения MsgContext<T> где T - типа эвента консьюмера, контекст содержит в себе полезную метадату в.т.ч. хедеры.

AttemptNumber в логе для стандартного ретраера MT

Эксепшн MTConsumerFailFastException для принудительного выхода из консьюмера без ретраев

C версии 9:

Исправлен эксепшн MTConsumerFailFastException для принудительного выхода из консьюмера без ретраев

C версии 10:

Исправление фэйлфаста для ретрая  RetryPolicyType.Masstransit

Шаблоны:

Строковые шаблоны имеют следующий вид:

параметры разделяются пробелами

Для RetryPolicyNone - "n" или "none".

   3. Остальные значения первого параметра "mt" или "masstransit", "rmq" или "rabbitmq". Это соответственно модель ретраев МТ в памяти или RMQ DLX.

   4. Второй параметр обозначает имя метода ретраера(допустимо использование любого из таблицы):

сокрашенное имя

полное

imm

immediate

exp

exponential

inc

incremental

intvl

interval

intvls

intervals

    5. Остальные параметры это перечисление значений параметров выбранного метода. Важно! Время задается в !минутах!, допустимы дробные значения. Пример 1.5 что обозначает полторы минуты, что приблизительно равно 90 секунд.

Пример шаблона экспоненциальных ретраев в памяти МТ:  "mt exp 2 0.5 1 0.5".

RMQ DLX

Данная система ретраев работает следующим образом:

обработка эвента падает с ошибкой.

консьюмер создает и публикует новый эвент с хедерами(tll = время до ретрая, номер ретрая) в эксчейндж DLX  очереди. DLX очередь имеет имя {имя исходной очереди}_DLX.

Происходит ack упавшего эвента.

   4. Копия упавшего эвента истекает по TTL в DLX очереди, после чего рэббит репаблишит истекший эвент в основную очередь для переобработки консьюмером.

Пример:

Аттрибут x-dead-letter-exchange указывает в какой эксчейндж будет переброшено сообщение по истечении.

Важно понимать при расширении либы в плане поддерживаемых моделей переотправки, что все ttl в очереди по значению должны быть одинаковы потому, что RMQ обрабатывает эвенты строго с "головы" очереди и будет висеть на первом эвенте пока тот не истечет, не переходя ко второму. Так что на каждый TTL нужен свой DLX Queue.

Логирование:

Ниже приведен пример лога генерируемого при обработке консьюмера. Логи падают при стандартном поведении через ILogger в консоль.

{
    "IsSuccessful": false, //статус обработки //c с версии 3.1.20220617.1 исправлин нейминг с IsSuccessfull -> IsSuccessful 
    "MqTopologyType": "Fanout", // тип эксчейнджа на который подписан консьюмер
    "Exchange": "102", //эксчейндж на который подписан консьюмер
    "Route": "", //routing key эксчейнджа на который подписан консьюмер(актуально, например, для типа эксчейнджа Topic)
    "Queue": "VisualStatuses_FormedForPassingToLogistician",//имя очереди консьюмера
    "StartTime": "2022-05-03T09:46:53.9752831+03:00", //время обработки начала эвента
    "EndTime": "2022-05-03T09:47:23.9859256+03:00", //время окончания обработки эвента
    "Elapsed": "0:00:00:30.0106425", //сколько ушло времени на обработку
    "Event": **, // обрабатываемый эвент в формате json 
    "Exception": "", // в случае "IsSuccessfull": false описание ошибки обработки
    "Result": ** // в случае "IsSuccessfull": true тут может быть возвращенный консьюмером объект результата в формате json
    "RetryAttempt":0 //номер ретрая(0 это ещё не ретрай, ретраи идут от 1), пишется только для RMQ DLX системы ретраев
}

   2. У сигнатуры консьюмера может быть возвращаемый тип.

[SubscribeOn("outerStatuses", ExchangeType.Topic, "#", retryPolicy: "mt exp 2 0.5 1 0.5")]
public Task<List<string>> Consume1(List<JsonText> events);

В примере выше это например List<string>, в принципе тип может быть любым, даже object. Данный результат выполнения будет сериализован в формат json и добавлен в поле "Result" лога.

Атрибуты консьюмера:

 [SubscribeOn( exchange:"outerStatuses", topologyType: ExchangeType.Topic, 
  route: "#", concurrentMessageLimit: 2, retryPolicy: "mt exp 2 0.5 1 0.5")]

Выше приведен базовый атрибут консьюмера.

Вот список параметров:

exchange - имя эксчейнджа для подписки

topologyType - тип эксчейнджа для подписки(смотрим доки RMQ)

route - ключ маршрутизации, указывается если эксчейндж их поддерживает.

concurrentMessageLimit - число параллельных консьюмеров одновременно работающих с очередью атрибута

retryPolicy - шаблон конфигурации ретраев консьюмера

У атрибута SubscribeOn есть наследники упрощающие подписку на разные типы эксченджей:

SubscribeBasicOn - fanout

SubscribeDirectOn - direct

SubscribeTopicOn - topic

Замечания:

Название очередей подписчиков в RMQ это по дефолту имя контроллера без "суффикса" Controller + _ + имя метода.

На уровне регистрации либки можно задать глобальный делегат дополнения имени очереди - параметр queueNamingChanger.

В случае коллизий именований, это в случае когда на одном методе много  атрибутов консьюмеров, к имени очереди будет добавляться суффикс _Exchange*номер эксчейнджа* и _Route*номер маршрута*(если необходим)

Не советую мешать джобы и консьюмеры на одном методе, не проверял что будет.

Атрибут джобов:

[RunJob("0/30 * * * * ?")]

Джоб это консьюмер вызываемый по расписанию, логируется как консьюмер, имеет свою очередь.

В качестве ретраев используется стандартная модель ретраев в памяти МТ по экспоненте.

Автогенерируемые по расписанию эвенты имеют ttl в половину(?!) интервала между точками расписания, чтобы не накапливаться в случае крупных сбоев.

Под капотом используется либка Quartz.Net, так что используется её нотация cron'a для задания расписаний.

На одном методе может быть несколько атрибутов джобов.

Не советую мешать джобы и консьюмеры на одном методе, не проверял что будет.

На текущий момент джобы не рассчитаны на то, что 1 сервис деплоится как несколько инстансов(но на стадии инициализации есть параметр configureJobEmitters, которым можно отрубить эмитер эвентов по расписанию в конкретном сервисе).

Атрибут для паблиша:

 [PublishMessage(exchangeType: ExchangeType.Topic, exchangeName: "outerStatusesV5", resolveTopology: true)]

exchangeType - тип эксчейнджа в который отправится эвент

exchangeName - имя ксчейнджа в который отправится эвент

resolveTopology - свойство определяющее будет ли MT проверять топологию и пытаться регенерировать её.

Замечания:

Зачем нужен этот атрибут? У МТ сильные ограничения по отправщику сообщений, если эвент не забиндили на стадии инициализации, то отправить его не получится. NB! Если вам нужно отправить эвент в эксчейндж типа fanout, то это получится сделать без атрибута. С другими эксчейнджами не прокатит(. Не пытайтесь использовать анонимные типы для отправки, оно так не работает.

Если хотите отправить массив эвентов [{},{},{}] наследуйтесь от List<> И вешайте на этот тип атрибут. Однако так делать КРАЙНЕ НЕ РЕКОМЕНДУЕТСЯ! Единственная причина для таких вещей это паблиш в старые эксчейнджи в которых эвенты упакованы в массивы.

Используйте метод PublishMessage<T> из либы. Это обертка по верх стандартного метода МТ - Publish с проверкой атрибутов отправляемого сообщения.

Раутинг, если есть, указывается в методе отправки эвента.

Для того чтобы избежать проблем с авто генерацией топологии, в случае если эвенты наследуются от какого-либо типа используйте атрибут [ExcludeFromTopology] на родительских классах.
